#  设计内容（数据部分）
## 对于相关数据结构体的分析
1. WAV_Format结构体用来储存WAV文件最开始的12个字节的信息，识别读取的文件是否为WAV格式。
2. WAV_FMT结构体用来储存WAV文件头的fmt数据块的信息，包括是否为PCM格式数据，比特率等。
3. CHUNK_INFO结构体用来读入一个CHUNK结构头8个字节的描述信息。
3. WAV_DATA结构体用来读入data数据块的头8个字节的描述信息，包括CHUNK标签（用来识别是否为data数据块）、数据块的大小等。
4. process结构体，用来记录数据包的取用相关的进度信息和取用步长信息。

## 对于相关位域的分析
1. Bit32用来储存16位双声道二进制音频数据，分为da，db两个域。分别是左声道，右声道的数据。
2. Bit16用来储存8位双声道二进制音频数据，分为da，db两个域。分别是左声道，右声道的数据。
3. BitO16用来储存16位单声道的二进制音频数据。
4. BitO8用来储存8位单声道的二进制音频数据。

## 对于WAV类的分析
1. 传入需要读入的WAV格式文件的路径，而后对于WAV格式的文件头进行通过二进制模式读取操作。为了提高程序的鲁棒性，程序通过while循环来读入，根据读入的标签的特点来进行下一步操作。这样，能够在处理少部分不和主流形式一致文件头的情况下，仍然能够正确读取文件中必要信息与相关数据。在读取data标签前，会对fmt标签是否已读入进行检查。在读取fmt标签时会检查文件数据是否为PCM格式。
2. 数据储存上，利用stdint.h中定义的uint32_t来保证一次读入4个字节，来符合标准规范。由于WAV文件头中包含很多个小节，针对这些小节及其特点建立了相关的结构体。用来一次性读入相关信息，确保读入的稳定性与安全性。
3. 在音频数据的处理上，由于PCM格式的音频输入含有16位双声道，8位双声道，16位单声道，8位单声道。对于这几种不同的类型，实际的处理方式会不同。在工程定义时，定义了4个不同的位域，用来分割不同类型下的二进制音频数据。并且对于这四种不同的位域，给它们配置了4中不同的容器来容纳。所以该类在识别音频文件后，会自动选择合适的容器（vector）来存放。
4. 对于WAV文件的数据的取用上，需要先通过setTimer方法来指定所取用的音频数据的持续时间，单位是ms，且要求小于1000ms。然后通过getData方法来进行数据包（抽象为Data类）的一次取用。该类通过process结构体储存当前数据包取用进度，返回储存正确位置数据的数据包。在取用数据包时，数据包会自动根据音频数据的类型来进行调整，降低用户手动操作的操作复杂度。用户可以根据返回的数据包内部的active变量来得知获取数据操作是否到了文件尾部。
5. 通过getInfo方法，程序可以直接打印WAV文件的相关主要信息。
